"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "fetchMock", {
  enumerable: true,
  get: function get() {
    return _fetchMock.default;
  }
});
exports.FetchMock = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _react = require("react");

var _fetchMock = _interopRequireDefault(require("fetch-mock"));

// Allow consumers to run assertions on the same instance of fetchMock
var FetchMock =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(FetchMock, _Component);

  function FetchMock(props) {
    var _this;

    (0, _classCallCheck2.default)(this, FetchMock);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FetchMock).call(this, props));

    _this.mock();

    return _this;
  }

  (0, _createClass2.default)(FetchMock, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // Make sure we don't clear a mock from a newer instance (since React 16
      // B.constructor is called before A.componentWillUnmount)
      if (_fetchMock.default.__fetchMockInst === this) {
        this.unmock();
      }
    }
  }, {
    key: "mock",
    value: function mock() {
      // Clear mocks from a previous FetchMock instance
      // NOTE: The last rendered FetchProxy instance will override mocks from
      // the previous ones
      this.unmock();
      var props = this.props;
      var config = props.config;

      if (config) {
        Object.keys(config).forEach(function (key) {
          _fetchMock.default.config[key] = config[key];
        });
      }

      if (props.mocks) {
        props.mocks.forEach(function (options) {
          _fetchMock.default.mock(options);
        });
      } else if (props.matcher) {
        _fetchMock.default.mock(props.matcher, props.response, props.options);
      } else if (props.options) {
        // NOTE: We shouldn't check `props.options` at this point, but for some
        // reason Flow doesn't get it.
        _fetchMock.default.mock(props.options);
      }

      _fetchMock.default.__fetchMockInst = this;
    }
  }, {
    key: "unmock",
    value: function unmock() {
      if (typeof _fetchMock.default.restore === 'function') {
        _fetchMock.default.restore();

        delete _fetchMock.default.__fetchMockInst;
      }
    }
  }]);
  return FetchMock;
}(_react.Component);

exports.FetchMock = FetchMock;